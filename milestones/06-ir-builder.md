## Чекпоинт 6. Построение IR-дерева

### Уложитесь в конец семестра

Мы создали с вами таблицу символов, систему типов. Теперь это необходимо переложить в IR.

Виды вершин (описание можно найти в [https://akht.pl/compilers2020-lecture08](https://akht.pl/compilers2020-lecture08) ):
* Expression
  * BINOP
  * CALL
  * CONST
  * ESEQ
  * MEM
  * NAME
  * TEMP
* Statement
  * EXP
  * CJUMP
  * LABEL
  * MOVE
  * SEQ
* ExpressionList

Подумайте, нужен ли StatementList для реализации.

Заметим, что инструкции могут быть представлены в разном виде, поэтому может быть полезен SubtreeWrapper, который будет преобразовывать
утверждения к разному типу.

Адаптируйте механизм Frame: разберите случаи `регистр` и `адрес во фрейме`, адаптируйте FunctionTable и Frame из предыдущего чекпоинта,
добавьте функции, которые позволяют адрес преобразовать в IR-выражение.


Зарезервируйте имя под FramePointer, Return Address, Return Value Address, this.

При реализации вызова метода класса, добавляйте this в качестве первого аргумента, это поможет определить, у какого экземпляра вызываются методы.
    
Примеры можно найти в [примере IR](/07-irtree-build).

Реализуйте для IR-дерева PrintVisitor.

Просьба в примерах продемонстрировать:
* `if(a)` - где `a` - `int`

Успехов!

P.S. Выполнение этого чекпоинта гарантирует закрытие курса!!!
